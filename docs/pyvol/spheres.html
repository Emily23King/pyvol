<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>pyvol.spheres API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyvol.spheres</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from . import utilities
from Bio.PDB import PDBParser
from Bio.PDB.ResidueDepth import _get_atom_radius
import glob
import itertools
import logging
import numpy as np
import os
import pandas as pd
import scipy
import shutil
import sys
import tempfile
import trimesh

logger = logging.getLogger(__name__)

class Spheres(object):
    &#34;&#34;&#34; &#34;&#34;&#34;

    def __init__(self,
                 xyz=None,
                 r=None,
                 xyzr=None,
                 xyzrg=None,
                 g=None,
                 pdb=None,
                 bv=None,
                 mesh=None,
                 name=None,
                 spheres_file=None):
        &#34;&#34;&#34;
        A Spheres object contains a list of xyz centers with r radii and g groups. It can be defined using xyzrg, xyzr (and optionally g), xyz (and optionally r or g), a pdb file (and optionally r or g), or a list of vertices with normals bounded by the spheres (requires r and optionally includes g)

        Args:
          xyz (float nx3): Array containing centers (Default value = None)
          r (float nx1): Array containing radii (Default value = None)
          xyzr (float nx4): Array containing centers and radii (Default value = None)
          xyzrg (float nx5): Array containing centers, radii, and groups (Default value = None)
          g (float nx1): Array containing groups (Default value = None)
          pdb (str): filename of a pdb to be processed into spheres (Default value = None)
          bv (float nx6): Array containing vertices and normals (Default value = None)
          mesh (Trimesh): mesh object describing the surface (Default value = None)
          name (str): descriptive identifier (Default value = None)
          spheres_file (str): filename of a Spheres file to be read from disk (Default value = None)
        &#34;&#34;&#34;

        if xyzrg is not None:
            self.xyzrg = xyzrg
        elif xyzr is not None:
            self.xyzr = xyzr

            if g is not None:
                self.g = g
        elif xyz is not None:
            self.xyz = xyz

            if r is not None:
                self.r = r
            if g is not None:
                self.g = g
        elif pdb is not None:
            if not sys.warnoptions:
                import warnings
                warnings.simplefilter(&#34;ignore&#34;)

            p = PDBParser(PERMISSIVE=1, QUIET=True)
            structure = p.get_structure(&#34;prot&#34;, pdb)

            self.xyz = np.array([atom.get_coord() for atom in structure[0].get_atoms()])

            if r is not None:
                self.r = r
            else:
                self.r = [_get_atom_radius(atom, rtype=&#39;united&#39;) for atom in structure[0].get_atoms()]

            if g is not None:
                self.g = g
        elif bv is not None and r is not None:
            self.xyz = bv[:, 0:3] + r * bv[:, 3:6]
            self.r = r
            self.remove_duplicates()

            if g is not None:
                self.g = g
        elif spheres_file is not None:
            csv_file = None
            obj_file = None

            base, ext = os.path.splitext(spheres_file)
            if ext == &#34;.csv&#34;:
                csv_file = spheres_file
                obj_file = &#34;{0}.obj&#34;.format(base)
            elif ext == &#34;.obj&#34;:
                csv_file = &#34;{0}.csv&#34;.format(base)
                obj_file = spheres_file
            else:
                logger.error(&#34;Invalid filename given to read in spheres object: {0}&#34;.format(spheres_file))
            spheres_data = np.loadtxt(csv_file, delimiter=&#39; &#39;)

            if spheres_data.shape[1] == 5:
                self.xyzrg = spheres_data
            elif spheres_data.shape[1] == 4:
                self.xyzr = spheres_data
            else:
                logger.error(&#34;Spheres csv file contains the wrong number of columns&#34;)
            mesh = trimesh.load_mesh(obj_file)

            if name is None:
                name = os.path.basename(base)

        if mesh is not None:
            self.mesh = mesh
        else:
            self.mesh = None

        if name is not None:
            self.name = name
        else:
            self.name = None


    def __add__(self, other):
        &#34;&#34;&#34;
        Create a new Spheres object by overloading addition to concatenate xyzr contents
        Does not add meshes (just spheres)
        &#34;&#34;&#34;

        if other is not None:
            return Spheres(xyzrg=np.concatenate([self.xyzrg, other.xyzrg], axis=0))
        else:
            return Spheres(xyzrg=np.copy(self.xyzrg))


    def copy(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return Spheres(xyzrg=np.copy(self.xyzrg))


    def calculate_surface(self, probe_radius=1.4, cavity_atom=None, coordinate=None, all_components=False, exclusionary_radius=2.5, largest_only=False, noh=True, minimum_volume=200):
        &#34;&#34;&#34;Calculate the SAS for a given probe radius

        Args:
          probe_radius (float): radius for surface calculations (Default value = 1.4)
          cavity_atom (int): id of a single atom which lies on the surface of the interior cavity of interest (Default value = None)
          coordinate ([float]): 3D coordinate to identify a cavity atom (Default value = None)
          all_components (bool): return all pockets? (Default value = False)
          exclusionary_radius (float): maximum permissibile distance to the closest identified surface element from the supplied coordinate (Default value = 2.5)
          largest_only (bool): return only the largest pocket? (Default value = False)
          noh (bool): remove waters before surface calculation? (Default value = True)
          minimum_volume (int): minimum volume of pockets returned when using &#39;all_components&#39; (Default value = 200)

        &#34;&#34;&#34;

        tmpdir = tempfile.mkdtemp()
        xyzr_file = os.path.join(tmpdir, &#34;pyvol.xyzr&#34;)
        msms_template = os.path.join(tmpdir, &#34;pyvol_msms&#34;)

        np.savetxt(xyzr_file, self.xyzr, delimiter=&#39; &#39;, fmt=&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.2f&#39;)
        if (cavity_atom is None) and (coordinate is not None):
            cavity_atom = self.nearest(coordinate, max_radius=exclusionary_radius)

        msms_cmd = [&#34;msms&#34;, &#34;-if&#34;, xyzr_file, &#34;-of&#34;, msms_template, &#34;-probe_radius&#34;, &#34;{0}&#34;.format(probe_radius), &#34;-no_area&#34;]
        if noh:
            msms_cmd.append(&#34;-noh&#34;)
        if cavity_atom is not None:
            msms_cmd.extend([&#34;-one_cavity&#34;, 1, cavity_atom])
        elif all_components:
            msms_cmd.append(&#34;-all_components&#34;)

        utilities.run_cmd(msms_cmd)

        sphere_list = []

        def read_msms_output(msms_template):
            &#34;&#34;&#34; Read the results of a MSMS run

            Args:
              msms_template (str): file prefix for the output from MSMS

            Returns:
              verts_raw (float nx6): raw contents of vertices file
              vertices (float nx3): 1-indexed 3D coordinates of vertices
              faces (float nx3): vertex connectivity graph
            &#34;&#34;&#34;
            try:
                verts_raw = pd.read_csv(&#34;{0}.vert&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, dtype=np.float_, header=None, encoding=&#39;latin1&#39;).values
                faces = pd.read_csv(&#34;{0}.face&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, usecols=[0, 1, 2], dtype=np.int_, header=None, encoding=&#39;latin1&#39;).values
            except IOError:
                logger.error(&#34;MSMS failed to run correctly for {0}&#34;.format(msms_template))
                raise IOError
            else:
                vertices = np.zeros((verts_raw.shape[0] + 1, 3))
                vertices[1:, :] = verts_raw[:, 0:3]
                return verts_raw, vertices, faces

        if not all_components:
            verts_raw, vertices, faces = read_msms_output(msms_template)

            mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
            if mesh.volume &lt; 0:
                faces = np.flip(faces, axis=1)
                mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
            bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=mesh)
            shutil.rmtree(tmpdir)
            logger.debug(&#34;Single volume calculated for {0}&#34;.format(self.name))
            return [bspheres]

        else:
            spheres_list = []
            ac_template_list = [os.path.splitext(x)[0] for x in glob.glob(&#34;{0}_*.face&#34;.format(msms_template))]
            logger.debug(&#34;{0} volumes calculated for {1}&#34;.format(len(ac_template_list), msms_template))

            largest_mesh = None
            for ac_template in ac_template_list:
                verts_raw, vertices, faces = read_msms_output(ac_template)

                tm = trimesh.base.Trimesh(vertices=vertices, faces=faces)
                if tm.volume &lt; 0:
                    tm = trimesh.base.Trimesh(vertices=vertices, faces=np.flip(faces, axis=1))

                if largest_only:
                    if largest_mesh is None:
                        largest_mesh = tm
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                    elif tm.volume &gt; largest_mesh.volume:
                        largest_mesh = tm
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                else:
                    if tm.volume &gt;= minimum_volume:
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                        spheres_list.append(bspheres)

            if largest_only:
                logger.debug(&#34;Largest volume identified for {0}&#34;.format(msms_template))
                return [bspheres]
            else:
                logger.debug(&#34;{0} volumes identified with sufficient volume for {0}&#34;.format(len(spheres_list), msms_template))
                return sorted(spheres_list, key=lambda s: s.mesh.volume, reverse=True)


    def identify_nonextraneous(self, ref_spheres, radius):
        &#34;&#34;&#34;Returns all spheres less than radius away from any center in ref_spheres using cKDTree search built on the non-reference set

        Args:
          ref_spheres (Spheres): object that defines the pocket of interest
          radius (float): maximum distance to sphere centers to be considered nonextraneous

        Returns:
          nonextraneous (Spheres): a filtered Spheres object

        &#34;&#34;&#34;

        kdtree = scipy.spatial.cKDTree(self.xyz)
        groups = kdtree.query_ball_point(ref_spheres.xyz, radius, n_jobs=-1)
        indices = np.unique(list(itertools.chain.from_iterable(groups)))

        logger.debug(&#34;Non-extraneous spheres removed&#34;)
        return Spheres(xyzrg=np.copy(self.xyzrg[indices, :]))


    def nearest(self, coordinate, max_radius=None):
        &#34;&#34;&#34; Returns the index of the sphere closest to a coordinate; if max_radius is specified, the sphere returned must have a radius &lt;= max_radius

        Args:
          coordinate (float nx3): 3D input coordinate
          max_radius (float): maximum permissibile distance to the nearest sphere (Default value = None)

        Returns:
          nearest_index: index of the closest sphere

        &#34;&#34;&#34;

        if max_radius is None:
            sphere_list = self.xyz
        else:
            sphere_list = self.xyz[self.r &lt;= max_radius]

        return np.argmin(scipy.spatial.distance.cdist(sphere_list, coordinate))


    def nearest_coord_to_external(self, coordinates):
        &#34;&#34;&#34; Returns the coordinate of the sphere closest to the supplied coordinates

        Args:
          coordinates (float nx3): set of coordinates

        Returns:
          coordinate (float 1x3): coordinate of internal sphere closest to the supplied coordinates

        &#34;&#34;&#34;

        kdtree = scipy.spatial.cKDTree(self.xyz)
        dist, indices = kdtree.query(coordinates, n_jobs=-1)

        return self.xyz[indices[np.argmin(dist)], :]


    def remove_duplicates(self, eps=0.01):
        &#34;&#34;&#34; Remove duplicate spheres by identifying centers closer together than eps using DBSCAN

        Args:
          eps (float): DBSCAN input parameter (Default value = 0.01)

        &#34;&#34;&#34;
        from sklearn.cluster import DBSCAN

        db = DBSCAN(eps=eps, min_samples=1).fit(self.xyz)
        values, indices = np.unique(db.labels_, return_index=True)
        self.xyzrg = self.xyzrg[indices, :]
        logger.debug(&#34;All sufficiently similar spheres removed&#34;)


    def remove_ungrouped(self):
        &#34;&#34;&#34; Remove all spheres that did not adequately cluster with the remainder of the set&#34;&#34;&#34;
        ungrouped_indices = np.where(self.g &lt; 1)
        self.xyzrg = np.delete(self.xyzrg, ungrouped_indices, axis=0)
        self.mesh = None


    def remove_groups(self, groups):
        &#34;&#34;&#34; Remove all spheres with specified group affiliations

        Args:
          groups ([float]): list of groups to remove

        &#34;&#34;&#34;
        group_indices = np.where(np.isin(self.g, groups))
        self.xyzrg = np.delete(self.xyzrg, group_indices, axis=0)
        self.mesh = None


    def write(self, filename, contents=&#34;xyzrg&#34;, output_mesh=True):
        &#34;&#34;&#34;Writes the contents of _xyzrg to a space delimited file

        Args:
          filename (str): filename to write the report and mesh if indicated
          contents (str): string describing which columns to write to file (Default value = &#34;xyzrg&#34;)
          output_mesh (bool): write mesh to file? (Default value = True)

        &#34;&#34;&#34;

        if contents == &#34;xyzrg&#34;:
            np.savetxt(filename, self.xyzrg, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyzrg file: {1}&#34;.format(self.name, filename))
        elif contents == &#34;xyzr&#34;:
            np.savetxt(filename, self.xyzr, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyzr file: {1}&#34;.format(self.name, filename))
        elif contents == &#34;xyz&#34;:
            np.savetxt(filename, self.xyz, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyz file: {1}&#34;.format(self.name, filename))

        if output_mesh:
            if self.mesh is None:
                logger.error(&#34;Cannot write out an uninitialized mesh&#34;)
            else:
                output_mesh = &#34;{0}.obj&#34;.format(os.path.splitext(filename)[0])
                self.mesh.export(file_obj = output_mesh)
                logger.debug(&#34;{0} written to obj file: {1}.obj&#34;.format(self.name, os.path.splitext(filename)[0]))

    @property
    def xyzrg(self):
        &#34;&#34;&#34; Retrieve the coordinates, radii, and group ids&#34;&#34;&#34;
        return self._xyzrg


    @xyzrg.setter
    def xyzrg(self, value):
        &#34;&#34;&#34; Set the coordinates, radii, and group ids

        Args:
          value (float 5xn): coordinates, radii, and group ids

        &#34;&#34;&#34;
        if value.shape[1] != 5:
            raise ValueError(&#34;number of xyzrg array columns must equal 5&#34;)
        self._xyzrg = np.copy(value).astype(float)


    @property
    def xyzr(self):
        &#34;&#34;&#34; Retrieve coordinates and radii &#34;&#34;&#34;
        return self._xyzrg[:, 0:4]


    @xyzr.setter
    def xyzr(self, value):
        &#34;&#34;&#34; Set the coordinates and radii

        Args:
          value (float 4xn): coordinates and radii

        &#34;&#34;&#34;
        # resets all radii, groups, and positions
        if value.shape[1] != 4:
            raise ValueError(&#34;number of xyzr array columns must equal 4&#34;)
        xyzrg = np.zeros((value.shape[0], 5))
        xyzrg[:, 0:4] = value
        self._xyzrg = np.copy(xyzrg).astype(float)


    @property
    def xyz(self):
        &#34;&#34;&#34; Retrieve the coordinates &#34;&#34;&#34;
        return self._xyzrg[:, 0:3]


    @xyz.setter
    def xyz(self, value):
        &#34;&#34;&#34; Selectively set the coordinates

        Args:
          value (float 3xn): coordinates

        &#34;&#34;&#34;
        # resets all radii, groups, and positions
        if value.shape[1] != 3:
            raise ValueError(&#34;number of xyz array columns must equal 3&#34;)
        xyzrg = np.zeros((value.shape[0], 5))
        xyzrg[:, 0:3] = value
        self._xyzrg = np.copy(xyzrg).astype(float)


    @property
    def r(self):
        &#34;&#34;&#34; Retrieve the radii &#34;&#34;&#34;
        return self._xyzrg[:, 3]


    @r.setter
    def r(self, value):
        &#34;&#34;&#34; Selectively set the radius index

        Args:
          value (float 1xn): radii

        &#34;&#34;&#34;
        if value is np.ndarray:
            if self._xyzrg.shape[0] == value.shape[0]:
                self._xyzrg[:, 3] = np.copy(value).astype(float)
            else:
                raise ValueError(&#34;Number of radii values must match the number of rows in the internal xyz array&#34;)
        else:
            self._xyzrg[:, 3] = value


    @property
    def g(self):
        &#34;&#34;&#34; Retrieve the group indices &#34;&#34;&#34;
        return self._xyzrg[:, 4]


    @g.setter
    def g(self, value):
        &#34;&#34;&#34; Selectively set the group index

        Args:
          value (float 1xn): group ids

        &#34;&#34;&#34;
        if value is np.ndarray:
            if self._xyzrg.shape[0] == value.shape[0]:
                self._xyzrg[:, 4] = np.copy(value).astype(float)
            else:
                raise ValueError(&#34;Number of group values must match the number of rows in the internal xyzr array&#34;)
        else:
            self._xyzrg[:, 4] = value.astype(float)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyvol.spheres.Spheres"><code class="flex name class">
<span>class <span class="ident">Spheres</span></span>
<span>(</span><span>xyz=None, r=None, xyzr=None, xyzrg=None, g=None, pdb=None, bv=None, mesh=None, name=None, spheres_file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A Spheres object contains a list of xyz centers with r radii and g groups. It can be defined using xyzrg, xyzr (and optionally g), xyz (and optionally r or g), a pdb file (and optionally r or g), or a list of vertices with normals bounded by the spheres (requires r and optionally includes g)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xyz</code></strong> :&ensp;<code>float</code> <code>nx3</code></dt>
<dd>Array containing centers (Default value = None)</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code> <code>nx1</code></dt>
<dd>Array containing radii (Default value = None)</dd>
<dt><strong><code>xyzr</code></strong> :&ensp;<code>float</code> <code>nx4</code></dt>
<dd>Array containing centers and radii (Default value = None)</dd>
<dt><strong><code>xyzrg</code></strong> :&ensp;<code>float</code> <code>nx5</code></dt>
<dd>Array containing centers, radii, and groups (Default value = None)</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>float</code> <code>nx1</code></dt>
<dd>Array containing groups (Default value = None)</dd>
<dt><strong><code>pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of a pdb to be processed into spheres (Default value = None)</dd>
<dt><strong><code>bv</code></strong> :&ensp;<code>float</code> <code>nx6</code></dt>
<dd>Array containing vertices and normals (Default value = None)</dd>
<dt><strong><code>mesh</code></strong> :&ensp;<code>Trimesh</code></dt>
<dd>mesh object describing the surface (Default value = None)</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>descriptive identifier (Default value = None)</dd>
<dt><strong><code>spheres_file</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of a Spheres file to be read from disk (Default value = None)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Spheres(object):
    &#34;&#34;&#34; &#34;&#34;&#34;

    def __init__(self,
                 xyz=None,
                 r=None,
                 xyzr=None,
                 xyzrg=None,
                 g=None,
                 pdb=None,
                 bv=None,
                 mesh=None,
                 name=None,
                 spheres_file=None):
        &#34;&#34;&#34;
        A Spheres object contains a list of xyz centers with r radii and g groups. It can be defined using xyzrg, xyzr (and optionally g), xyz (and optionally r or g), a pdb file (and optionally r or g), or a list of vertices with normals bounded by the spheres (requires r and optionally includes g)

        Args:
          xyz (float nx3): Array containing centers (Default value = None)
          r (float nx1): Array containing radii (Default value = None)
          xyzr (float nx4): Array containing centers and radii (Default value = None)
          xyzrg (float nx5): Array containing centers, radii, and groups (Default value = None)
          g (float nx1): Array containing groups (Default value = None)
          pdb (str): filename of a pdb to be processed into spheres (Default value = None)
          bv (float nx6): Array containing vertices and normals (Default value = None)
          mesh (Trimesh): mesh object describing the surface (Default value = None)
          name (str): descriptive identifier (Default value = None)
          spheres_file (str): filename of a Spheres file to be read from disk (Default value = None)
        &#34;&#34;&#34;

        if xyzrg is not None:
            self.xyzrg = xyzrg
        elif xyzr is not None:
            self.xyzr = xyzr

            if g is not None:
                self.g = g
        elif xyz is not None:
            self.xyz = xyz

            if r is not None:
                self.r = r
            if g is not None:
                self.g = g
        elif pdb is not None:
            if not sys.warnoptions:
                import warnings
                warnings.simplefilter(&#34;ignore&#34;)

            p = PDBParser(PERMISSIVE=1, QUIET=True)
            structure = p.get_structure(&#34;prot&#34;, pdb)

            self.xyz = np.array([atom.get_coord() for atom in structure[0].get_atoms()])

            if r is not None:
                self.r = r
            else:
                self.r = [_get_atom_radius(atom, rtype=&#39;united&#39;) for atom in structure[0].get_atoms()]

            if g is not None:
                self.g = g
        elif bv is not None and r is not None:
            self.xyz = bv[:, 0:3] + r * bv[:, 3:6]
            self.r = r
            self.remove_duplicates()

            if g is not None:
                self.g = g
        elif spheres_file is not None:
            csv_file = None
            obj_file = None

            base, ext = os.path.splitext(spheres_file)
            if ext == &#34;.csv&#34;:
                csv_file = spheres_file
                obj_file = &#34;{0}.obj&#34;.format(base)
            elif ext == &#34;.obj&#34;:
                csv_file = &#34;{0}.csv&#34;.format(base)
                obj_file = spheres_file
            else:
                logger.error(&#34;Invalid filename given to read in spheres object: {0}&#34;.format(spheres_file))
            spheres_data = np.loadtxt(csv_file, delimiter=&#39; &#39;)

            if spheres_data.shape[1] == 5:
                self.xyzrg = spheres_data
            elif spheres_data.shape[1] == 4:
                self.xyzr = spheres_data
            else:
                logger.error(&#34;Spheres csv file contains the wrong number of columns&#34;)
            mesh = trimesh.load_mesh(obj_file)

            if name is None:
                name = os.path.basename(base)

        if mesh is not None:
            self.mesh = mesh
        else:
            self.mesh = None

        if name is not None:
            self.name = name
        else:
            self.name = None


    def __add__(self, other):
        &#34;&#34;&#34;
        Create a new Spheres object by overloading addition to concatenate xyzr contents
        Does not add meshes (just spheres)
        &#34;&#34;&#34;

        if other is not None:
            return Spheres(xyzrg=np.concatenate([self.xyzrg, other.xyzrg], axis=0))
        else:
            return Spheres(xyzrg=np.copy(self.xyzrg))


    def copy(self):
        &#34;&#34;&#34; &#34;&#34;&#34;
        return Spheres(xyzrg=np.copy(self.xyzrg))


    def calculate_surface(self, probe_radius=1.4, cavity_atom=None, coordinate=None, all_components=False, exclusionary_radius=2.5, largest_only=False, noh=True, minimum_volume=200):
        &#34;&#34;&#34;Calculate the SAS for a given probe radius

        Args:
          probe_radius (float): radius for surface calculations (Default value = 1.4)
          cavity_atom (int): id of a single atom which lies on the surface of the interior cavity of interest (Default value = None)
          coordinate ([float]): 3D coordinate to identify a cavity atom (Default value = None)
          all_components (bool): return all pockets? (Default value = False)
          exclusionary_radius (float): maximum permissibile distance to the closest identified surface element from the supplied coordinate (Default value = 2.5)
          largest_only (bool): return only the largest pocket? (Default value = False)
          noh (bool): remove waters before surface calculation? (Default value = True)
          minimum_volume (int): minimum volume of pockets returned when using &#39;all_components&#39; (Default value = 200)

        &#34;&#34;&#34;

        tmpdir = tempfile.mkdtemp()
        xyzr_file = os.path.join(tmpdir, &#34;pyvol.xyzr&#34;)
        msms_template = os.path.join(tmpdir, &#34;pyvol_msms&#34;)

        np.savetxt(xyzr_file, self.xyzr, delimiter=&#39; &#39;, fmt=&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.2f&#39;)
        if (cavity_atom is None) and (coordinate is not None):
            cavity_atom = self.nearest(coordinate, max_radius=exclusionary_radius)

        msms_cmd = [&#34;msms&#34;, &#34;-if&#34;, xyzr_file, &#34;-of&#34;, msms_template, &#34;-probe_radius&#34;, &#34;{0}&#34;.format(probe_radius), &#34;-no_area&#34;]
        if noh:
            msms_cmd.append(&#34;-noh&#34;)
        if cavity_atom is not None:
            msms_cmd.extend([&#34;-one_cavity&#34;, 1, cavity_atom])
        elif all_components:
            msms_cmd.append(&#34;-all_components&#34;)

        utilities.run_cmd(msms_cmd)

        sphere_list = []

        def read_msms_output(msms_template):
            &#34;&#34;&#34; Read the results of a MSMS run

            Args:
              msms_template (str): file prefix for the output from MSMS

            Returns:
              verts_raw (float nx6): raw contents of vertices file
              vertices (float nx3): 1-indexed 3D coordinates of vertices
              faces (float nx3): vertex connectivity graph
            &#34;&#34;&#34;
            try:
                verts_raw = pd.read_csv(&#34;{0}.vert&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, dtype=np.float_, header=None, encoding=&#39;latin1&#39;).values
                faces = pd.read_csv(&#34;{0}.face&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, usecols=[0, 1, 2], dtype=np.int_, header=None, encoding=&#39;latin1&#39;).values
            except IOError:
                logger.error(&#34;MSMS failed to run correctly for {0}&#34;.format(msms_template))
                raise IOError
            else:
                vertices = np.zeros((verts_raw.shape[0] + 1, 3))
                vertices[1:, :] = verts_raw[:, 0:3]
                return verts_raw, vertices, faces

        if not all_components:
            verts_raw, vertices, faces = read_msms_output(msms_template)

            mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
            if mesh.volume &lt; 0:
                faces = np.flip(faces, axis=1)
                mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
            bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=mesh)
            shutil.rmtree(tmpdir)
            logger.debug(&#34;Single volume calculated for {0}&#34;.format(self.name))
            return [bspheres]

        else:
            spheres_list = []
            ac_template_list = [os.path.splitext(x)[0] for x in glob.glob(&#34;{0}_*.face&#34;.format(msms_template))]
            logger.debug(&#34;{0} volumes calculated for {1}&#34;.format(len(ac_template_list), msms_template))

            largest_mesh = None
            for ac_template in ac_template_list:
                verts_raw, vertices, faces = read_msms_output(ac_template)

                tm = trimesh.base.Trimesh(vertices=vertices, faces=faces)
                if tm.volume &lt; 0:
                    tm = trimesh.base.Trimesh(vertices=vertices, faces=np.flip(faces, axis=1))

                if largest_only:
                    if largest_mesh is None:
                        largest_mesh = tm
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                    elif tm.volume &gt; largest_mesh.volume:
                        largest_mesh = tm
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                else:
                    if tm.volume &gt;= minimum_volume:
                        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                        spheres_list.append(bspheres)

            if largest_only:
                logger.debug(&#34;Largest volume identified for {0}&#34;.format(msms_template))
                return [bspheres]
            else:
                logger.debug(&#34;{0} volumes identified with sufficient volume for {0}&#34;.format(len(spheres_list), msms_template))
                return sorted(spheres_list, key=lambda s: s.mesh.volume, reverse=True)


    def identify_nonextraneous(self, ref_spheres, radius):
        &#34;&#34;&#34;Returns all spheres less than radius away from any center in ref_spheres using cKDTree search built on the non-reference set

        Args:
          ref_spheres (Spheres): object that defines the pocket of interest
          radius (float): maximum distance to sphere centers to be considered nonextraneous

        Returns:
          nonextraneous (Spheres): a filtered Spheres object

        &#34;&#34;&#34;

        kdtree = scipy.spatial.cKDTree(self.xyz)
        groups = kdtree.query_ball_point(ref_spheres.xyz, radius, n_jobs=-1)
        indices = np.unique(list(itertools.chain.from_iterable(groups)))

        logger.debug(&#34;Non-extraneous spheres removed&#34;)
        return Spheres(xyzrg=np.copy(self.xyzrg[indices, :]))


    def nearest(self, coordinate, max_radius=None):
        &#34;&#34;&#34; Returns the index of the sphere closest to a coordinate; if max_radius is specified, the sphere returned must have a radius &lt;= max_radius

        Args:
          coordinate (float nx3): 3D input coordinate
          max_radius (float): maximum permissibile distance to the nearest sphere (Default value = None)

        Returns:
          nearest_index: index of the closest sphere

        &#34;&#34;&#34;

        if max_radius is None:
            sphere_list = self.xyz
        else:
            sphere_list = self.xyz[self.r &lt;= max_radius]

        return np.argmin(scipy.spatial.distance.cdist(sphere_list, coordinate))


    def nearest_coord_to_external(self, coordinates):
        &#34;&#34;&#34; Returns the coordinate of the sphere closest to the supplied coordinates

        Args:
          coordinates (float nx3): set of coordinates

        Returns:
          coordinate (float 1x3): coordinate of internal sphere closest to the supplied coordinates

        &#34;&#34;&#34;

        kdtree = scipy.spatial.cKDTree(self.xyz)
        dist, indices = kdtree.query(coordinates, n_jobs=-1)

        return self.xyz[indices[np.argmin(dist)], :]


    def remove_duplicates(self, eps=0.01):
        &#34;&#34;&#34; Remove duplicate spheres by identifying centers closer together than eps using DBSCAN

        Args:
          eps (float): DBSCAN input parameter (Default value = 0.01)

        &#34;&#34;&#34;
        from sklearn.cluster import DBSCAN

        db = DBSCAN(eps=eps, min_samples=1).fit(self.xyz)
        values, indices = np.unique(db.labels_, return_index=True)
        self.xyzrg = self.xyzrg[indices, :]
        logger.debug(&#34;All sufficiently similar spheres removed&#34;)


    def remove_ungrouped(self):
        &#34;&#34;&#34; Remove all spheres that did not adequately cluster with the remainder of the set&#34;&#34;&#34;
        ungrouped_indices = np.where(self.g &lt; 1)
        self.xyzrg = np.delete(self.xyzrg, ungrouped_indices, axis=0)
        self.mesh = None


    def remove_groups(self, groups):
        &#34;&#34;&#34; Remove all spheres with specified group affiliations

        Args:
          groups ([float]): list of groups to remove

        &#34;&#34;&#34;
        group_indices = np.where(np.isin(self.g, groups))
        self.xyzrg = np.delete(self.xyzrg, group_indices, axis=0)
        self.mesh = None


    def write(self, filename, contents=&#34;xyzrg&#34;, output_mesh=True):
        &#34;&#34;&#34;Writes the contents of _xyzrg to a space delimited file

        Args:
          filename (str): filename to write the report and mesh if indicated
          contents (str): string describing which columns to write to file (Default value = &#34;xyzrg&#34;)
          output_mesh (bool): write mesh to file? (Default value = True)

        &#34;&#34;&#34;

        if contents == &#34;xyzrg&#34;:
            np.savetxt(filename, self.xyzrg, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyzrg file: {1}&#34;.format(self.name, filename))
        elif contents == &#34;xyzr&#34;:
            np.savetxt(filename, self.xyzr, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyzr file: {1}&#34;.format(self.name, filename))
        elif contents == &#34;xyz&#34;:
            np.savetxt(filename, self.xyz, delimiter=&#39; &#39;)
            logger.debug(&#34;{0} written to xyz file: {1}&#34;.format(self.name, filename))

        if output_mesh:
            if self.mesh is None:
                logger.error(&#34;Cannot write out an uninitialized mesh&#34;)
            else:
                output_mesh = &#34;{0}.obj&#34;.format(os.path.splitext(filename)[0])
                self.mesh.export(file_obj = output_mesh)
                logger.debug(&#34;{0} written to obj file: {1}.obj&#34;.format(self.name, os.path.splitext(filename)[0]))

    @property
    def xyzrg(self):
        &#34;&#34;&#34; Retrieve the coordinates, radii, and group ids&#34;&#34;&#34;
        return self._xyzrg


    @xyzrg.setter
    def xyzrg(self, value):
        &#34;&#34;&#34; Set the coordinates, radii, and group ids

        Args:
          value (float 5xn): coordinates, radii, and group ids

        &#34;&#34;&#34;
        if value.shape[1] != 5:
            raise ValueError(&#34;number of xyzrg array columns must equal 5&#34;)
        self._xyzrg = np.copy(value).astype(float)


    @property
    def xyzr(self):
        &#34;&#34;&#34; Retrieve coordinates and radii &#34;&#34;&#34;
        return self._xyzrg[:, 0:4]


    @xyzr.setter
    def xyzr(self, value):
        &#34;&#34;&#34; Set the coordinates and radii

        Args:
          value (float 4xn): coordinates and radii

        &#34;&#34;&#34;
        # resets all radii, groups, and positions
        if value.shape[1] != 4:
            raise ValueError(&#34;number of xyzr array columns must equal 4&#34;)
        xyzrg = np.zeros((value.shape[0], 5))
        xyzrg[:, 0:4] = value
        self._xyzrg = np.copy(xyzrg).astype(float)


    @property
    def xyz(self):
        &#34;&#34;&#34; Retrieve the coordinates &#34;&#34;&#34;
        return self._xyzrg[:, 0:3]


    @xyz.setter
    def xyz(self, value):
        &#34;&#34;&#34; Selectively set the coordinates

        Args:
          value (float 3xn): coordinates

        &#34;&#34;&#34;
        # resets all radii, groups, and positions
        if value.shape[1] != 3:
            raise ValueError(&#34;number of xyz array columns must equal 3&#34;)
        xyzrg = np.zeros((value.shape[0], 5))
        xyzrg[:, 0:3] = value
        self._xyzrg = np.copy(xyzrg).astype(float)


    @property
    def r(self):
        &#34;&#34;&#34; Retrieve the radii &#34;&#34;&#34;
        return self._xyzrg[:, 3]


    @r.setter
    def r(self, value):
        &#34;&#34;&#34; Selectively set the radius index

        Args:
          value (float 1xn): radii

        &#34;&#34;&#34;
        if value is np.ndarray:
            if self._xyzrg.shape[0] == value.shape[0]:
                self._xyzrg[:, 3] = np.copy(value).astype(float)
            else:
                raise ValueError(&#34;Number of radii values must match the number of rows in the internal xyz array&#34;)
        else:
            self._xyzrg[:, 3] = value


    @property
    def g(self):
        &#34;&#34;&#34; Retrieve the group indices &#34;&#34;&#34;
        return self._xyzrg[:, 4]


    @g.setter
    def g(self, value):
        &#34;&#34;&#34; Selectively set the group index

        Args:
          value (float 1xn): group ids

        &#34;&#34;&#34;
        if value is np.ndarray:
            if self._xyzrg.shape[0] == value.shape[0]:
                self._xyzrg[:, 4] = np.copy(value).astype(float)
            else:
                raise ValueError(&#34;Number of group values must match the number of rows in the internal xyzr array&#34;)
        else:
            self._xyzrg[:, 4] = value.astype(float)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyvol.spheres.Spheres.g"><code class="name">var <span class="ident">g</span></code></dt>
<dd>
<section class="desc"><p>Retrieve the group indices</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def g(self):
    &#34;&#34;&#34; Retrieve the group indices &#34;&#34;&#34;
    return self._xyzrg[:, 4]</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<section class="desc"><p>Retrieve the radii</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def r(self):
    &#34;&#34;&#34; Retrieve the radii &#34;&#34;&#34;
    return self._xyzrg[:, 3]</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.xyz"><code class="name">var <span class="ident">xyz</span></code></dt>
<dd>
<section class="desc"><p>Retrieve the coordinates</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xyz(self):
    &#34;&#34;&#34; Retrieve the coordinates &#34;&#34;&#34;
    return self._xyzrg[:, 0:3]</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.xyzr"><code class="name">var <span class="ident">xyzr</span></code></dt>
<dd>
<section class="desc"><p>Retrieve coordinates and radii</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xyzr(self):
    &#34;&#34;&#34; Retrieve coordinates and radii &#34;&#34;&#34;
    return self._xyzrg[:, 0:4]</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.xyzrg"><code class="name">var <span class="ident">xyzrg</span></code></dt>
<dd>
<section class="desc"><p>Retrieve the coordinates, radii, and group ids</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xyzrg(self):
    &#34;&#34;&#34; Retrieve the coordinates, radii, and group ids&#34;&#34;&#34;
    return self._xyzrg</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyvol.spheres.Spheres.calculate_surface"><code class="name flex">
<span>def <span class="ident">calculate_surface</span></span>(<span>self, probe_radius=1.4, cavity_atom=None, coordinate=None, all_components=False, exclusionary_radius=2.5, largest_only=False, noh=True, minimum_volume=200)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the SAS for a given probe radius</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>probe_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius for surface calculations (Default value = 1.4)</dd>
<dt><strong><code>cavity_atom</code></strong> :&ensp;<code>int</code></dt>
<dd>id of a single atom which lies on the surface of the interior cavity of interest (Default value = None)</dd>
<dt><strong><code>coordinate</code></strong> :&ensp;[<code>float</code>]</dt>
<dd>3D coordinate to identify a cavity atom (Default value = None)</dd>
<dt><strong><code>all_components</code></strong> :&ensp;<code>bool</code></dt>
<dd>return all pockets? (Default value = False)</dd>
<dt><strong><code>exclusionary_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>maximum permissibile distance to the closest identified surface element from the supplied coordinate (Default value = 2.5)</dd>
<dt><strong><code>largest_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>return only the largest pocket? (Default value = False)</dd>
<dt><strong><code>noh</code></strong> :&ensp;<code>bool</code></dt>
<dd>remove waters before surface calculation? (Default value = True)</dd>
<dt><strong><code>minimum_volume</code></strong> :&ensp;<code>int</code></dt>
<dd>minimum volume of pockets returned when using 'all_components' (Default value = 200)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_surface(self, probe_radius=1.4, cavity_atom=None, coordinate=None, all_components=False, exclusionary_radius=2.5, largest_only=False, noh=True, minimum_volume=200):
    &#34;&#34;&#34;Calculate the SAS for a given probe radius

    Args:
      probe_radius (float): radius for surface calculations (Default value = 1.4)
      cavity_atom (int): id of a single atom which lies on the surface of the interior cavity of interest (Default value = None)
      coordinate ([float]): 3D coordinate to identify a cavity atom (Default value = None)
      all_components (bool): return all pockets? (Default value = False)
      exclusionary_radius (float): maximum permissibile distance to the closest identified surface element from the supplied coordinate (Default value = 2.5)
      largest_only (bool): return only the largest pocket? (Default value = False)
      noh (bool): remove waters before surface calculation? (Default value = True)
      minimum_volume (int): minimum volume of pockets returned when using &#39;all_components&#39; (Default value = 200)

    &#34;&#34;&#34;

    tmpdir = tempfile.mkdtemp()
    xyzr_file = os.path.join(tmpdir, &#34;pyvol.xyzr&#34;)
    msms_template = os.path.join(tmpdir, &#34;pyvol_msms&#34;)

    np.savetxt(xyzr_file, self.xyzr, delimiter=&#39; &#39;, fmt=&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.3f&#39;+&#39;% 1.2f&#39;)
    if (cavity_atom is None) and (coordinate is not None):
        cavity_atom = self.nearest(coordinate, max_radius=exclusionary_radius)

    msms_cmd = [&#34;msms&#34;, &#34;-if&#34;, xyzr_file, &#34;-of&#34;, msms_template, &#34;-probe_radius&#34;, &#34;{0}&#34;.format(probe_radius), &#34;-no_area&#34;]
    if noh:
        msms_cmd.append(&#34;-noh&#34;)
    if cavity_atom is not None:
        msms_cmd.extend([&#34;-one_cavity&#34;, 1, cavity_atom])
    elif all_components:
        msms_cmd.append(&#34;-all_components&#34;)

    utilities.run_cmd(msms_cmd)

    sphere_list = []

    def read_msms_output(msms_template):
        &#34;&#34;&#34; Read the results of a MSMS run

        Args:
          msms_template (str): file prefix for the output from MSMS

        Returns:
          verts_raw (float nx6): raw contents of vertices file
          vertices (float nx3): 1-indexed 3D coordinates of vertices
          faces (float nx3): vertex connectivity graph
        &#34;&#34;&#34;
        try:
            verts_raw = pd.read_csv(&#34;{0}.vert&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, dtype=np.float_, header=None, encoding=&#39;latin1&#39;).values
            faces = pd.read_csv(&#34;{0}.face&#34;.format(msms_template), sep=&#39;\s+&#39;, skiprows=3, usecols=[0, 1, 2], dtype=np.int_, header=None, encoding=&#39;latin1&#39;).values
        except IOError:
            logger.error(&#34;MSMS failed to run correctly for {0}&#34;.format(msms_template))
            raise IOError
        else:
            vertices = np.zeros((verts_raw.shape[0] + 1, 3))
            vertices[1:, :] = verts_raw[:, 0:3]
            return verts_raw, vertices, faces

    if not all_components:
        verts_raw, vertices, faces = read_msms_output(msms_template)

        mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
        if mesh.volume &lt; 0:
            faces = np.flip(faces, axis=1)
            mesh = trimesh.base.Trimesh(vertices=vertices, faces=faces)
        bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=mesh)
        shutil.rmtree(tmpdir)
        logger.debug(&#34;Single volume calculated for {0}&#34;.format(self.name))
        return [bspheres]

    else:
        spheres_list = []
        ac_template_list = [os.path.splitext(x)[0] for x in glob.glob(&#34;{0}_*.face&#34;.format(msms_template))]
        logger.debug(&#34;{0} volumes calculated for {1}&#34;.format(len(ac_template_list), msms_template))

        largest_mesh = None
        for ac_template in ac_template_list:
            verts_raw, vertices, faces = read_msms_output(ac_template)

            tm = trimesh.base.Trimesh(vertices=vertices, faces=faces)
            if tm.volume &lt; 0:
                tm = trimesh.base.Trimesh(vertices=vertices, faces=np.flip(faces, axis=1))

            if largest_only:
                if largest_mesh is None:
                    largest_mesh = tm
                    bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                elif tm.volume &gt; largest_mesh.volume:
                    largest_mesh = tm
                    bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
            else:
                if tm.volume &gt;= minimum_volume:
                    bspheres = Spheres(bv=verts_raw, r=probe_radius, mesh=tm)
                    spheres_list.append(bspheres)

        if largest_only:
            logger.debug(&#34;Largest volume identified for {0}&#34;.format(msms_template))
            return [bspheres]
        else:
            logger.debug(&#34;{0} volumes identified with sufficient volume for {0}&#34;.format(len(spheres_list), msms_template))
            return sorted(spheres_list, key=lambda s: s.mesh.volume, reverse=True)</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34; &#34;&#34;&#34;
    return Spheres(xyzrg=np.copy(self.xyzrg))</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.identify_nonextraneous"><code class="name flex">
<span>def <span class="ident">identify_nonextraneous</span></span>(<span>self, ref_spheres, radius)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns all spheres less than radius away from any center in ref_spheres using cKDTree search built on the non-reference set</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ref_spheres</code></strong> :&ensp;<a title="pyvol.spheres.Spheres" href="#pyvol.spheres.Spheres"><code>Spheres</code></a></dt>
<dd>object that defines the pocket of interest</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>maximum distance to sphere centers to be considered nonextraneous</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nonextraneous</code></strong> :&ensp;<a title="pyvol.spheres.Spheres" href="#pyvol.spheres.Spheres"><code>Spheres</code></a></dt>
<dd>a filtered Spheres object</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_nonextraneous(self, ref_spheres, radius):
    &#34;&#34;&#34;Returns all spheres less than radius away from any center in ref_spheres using cKDTree search built on the non-reference set

    Args:
      ref_spheres (Spheres): object that defines the pocket of interest
      radius (float): maximum distance to sphere centers to be considered nonextraneous

    Returns:
      nonextraneous (Spheres): a filtered Spheres object

    &#34;&#34;&#34;

    kdtree = scipy.spatial.cKDTree(self.xyz)
    groups = kdtree.query_ball_point(ref_spheres.xyz, radius, n_jobs=-1)
    indices = np.unique(list(itertools.chain.from_iterable(groups)))

    logger.debug(&#34;Non-extraneous spheres removed&#34;)
    return Spheres(xyzrg=np.copy(self.xyzrg[indices, :]))</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.nearest"><code class="name flex">
<span>def <span class="ident">nearest</span></span>(<span>self, coordinate, max_radius=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the index of the sphere closest to a coordinate; if max_radius is specified, the sphere returned must have a radius &lt;= max_radius</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinate</code></strong> :&ensp;<code>float</code> <code>nx3</code></dt>
<dd>3D input coordinate</dd>
<dt><strong><code>max_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>maximum permissibile distance to the nearest sphere (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nearest_index</code></strong></dt>
<dd>index of the closest sphere</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest(self, coordinate, max_radius=None):
    &#34;&#34;&#34; Returns the index of the sphere closest to a coordinate; if max_radius is specified, the sphere returned must have a radius &lt;= max_radius

    Args:
      coordinate (float nx3): 3D input coordinate
      max_radius (float): maximum permissibile distance to the nearest sphere (Default value = None)

    Returns:
      nearest_index: index of the closest sphere

    &#34;&#34;&#34;

    if max_radius is None:
        sphere_list = self.xyz
    else:
        sphere_list = self.xyz[self.r &lt;= max_radius]

    return np.argmin(scipy.spatial.distance.cdist(sphere_list, coordinate))</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.nearest_coord_to_external"><code class="name flex">
<span>def <span class="ident">nearest_coord_to_external</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the coordinate of the sphere closest to the supplied coordinates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>float</code> <code>nx3</code></dt>
<dd>set of coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coordinate</code></strong> :&ensp;<code>float</code> <code>1x3</code></dt>
<dd>coordinate of internal sphere closest to the supplied coordinates</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_coord_to_external(self, coordinates):
    &#34;&#34;&#34; Returns the coordinate of the sphere closest to the supplied coordinates

    Args:
      coordinates (float nx3): set of coordinates

    Returns:
      coordinate (float 1x3): coordinate of internal sphere closest to the supplied coordinates

    &#34;&#34;&#34;

    kdtree = scipy.spatial.cKDTree(self.xyz)
    dist, indices = kdtree.query(coordinates, n_jobs=-1)

    return self.xyz[indices[np.argmin(dist)], :]</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.remove_duplicates"><code class="name flex">
<span>def <span class="ident">remove_duplicates</span></span>(<span>self, eps=0.01)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove duplicate spheres by identifying centers closer together than eps using DBSCAN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code></dt>
<dd>DBSCAN input parameter (Default value = 0.01)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_duplicates(self, eps=0.01):
    &#34;&#34;&#34; Remove duplicate spheres by identifying centers closer together than eps using DBSCAN

    Args:
      eps (float): DBSCAN input parameter (Default value = 0.01)

    &#34;&#34;&#34;
    from sklearn.cluster import DBSCAN

    db = DBSCAN(eps=eps, min_samples=1).fit(self.xyz)
    values, indices = np.unique(db.labels_, return_index=True)
    self.xyzrg = self.xyzrg[indices, :]
    logger.debug(&#34;All sufficiently similar spheres removed&#34;)</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.remove_groups"><code class="name flex">
<span>def <span class="ident">remove_groups</span></span>(<span>self, groups)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all spheres with specified group affiliations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>groups</code></strong> :&ensp;[<code>float</code>]</dt>
<dd>list of groups to remove</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_groups(self, groups):
    &#34;&#34;&#34; Remove all spheres with specified group affiliations

    Args:
      groups ([float]): list of groups to remove

    &#34;&#34;&#34;
    group_indices = np.where(np.isin(self.g, groups))
    self.xyzrg = np.delete(self.xyzrg, group_indices, axis=0)
    self.mesh = None</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.remove_ungrouped"><code class="name flex">
<span>def <span class="ident">remove_ungrouped</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all spheres that did not adequately cluster with the remainder of the set</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_ungrouped(self):
    &#34;&#34;&#34; Remove all spheres that did not adequately cluster with the remainder of the set&#34;&#34;&#34;
    ungrouped_indices = np.where(self.g &lt; 1)
    self.xyzrg = np.delete(self.xyzrg, ungrouped_indices, axis=0)
    self.mesh = None</code></pre>
</details>
</dd>
<dt id="pyvol.spheres.Spheres.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, filename, contents='xyzrg', output_mesh=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Writes the contents of _xyzrg to a space delimited file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to write the report and mesh if indicated</dd>
<dt><strong><code>contents</code></strong> :&ensp;<code>str</code></dt>
<dd>string describing which columns to write to file (Default value = "xyzrg")</dd>
<dt><strong><code>output_mesh</code></strong> :&ensp;<code>bool</code></dt>
<dd>write mesh to file? (Default value = True)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, filename, contents=&#34;xyzrg&#34;, output_mesh=True):
    &#34;&#34;&#34;Writes the contents of _xyzrg to a space delimited file

    Args:
      filename (str): filename to write the report and mesh if indicated
      contents (str): string describing which columns to write to file (Default value = &#34;xyzrg&#34;)
      output_mesh (bool): write mesh to file? (Default value = True)

    &#34;&#34;&#34;

    if contents == &#34;xyzrg&#34;:
        np.savetxt(filename, self.xyzrg, delimiter=&#39; &#39;)
        logger.debug(&#34;{0} written to xyzrg file: {1}&#34;.format(self.name, filename))
    elif contents == &#34;xyzr&#34;:
        np.savetxt(filename, self.xyzr, delimiter=&#39; &#39;)
        logger.debug(&#34;{0} written to xyzr file: {1}&#34;.format(self.name, filename))
    elif contents == &#34;xyz&#34;:
        np.savetxt(filename, self.xyz, delimiter=&#39; &#39;)
        logger.debug(&#34;{0} written to xyz file: {1}&#34;.format(self.name, filename))

    if output_mesh:
        if self.mesh is None:
            logger.error(&#34;Cannot write out an uninitialized mesh&#34;)
        else:
            output_mesh = &#34;{0}.obj&#34;.format(os.path.splitext(filename)[0])
            self.mesh.export(file_obj = output_mesh)
            logger.debug(&#34;{0} written to obj file: {1}.obj&#34;.format(self.name, os.path.splitext(filename)[0]))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyvol" href="index.html">pyvol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyvol.spheres.Spheres" href="#pyvol.spheres.Spheres">Spheres</a></code></h4>
<ul class="">
<li><code><a title="pyvol.spheres.Spheres.calculate_surface" href="#pyvol.spheres.Spheres.calculate_surface">calculate_surface</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.copy" href="#pyvol.spheres.Spheres.copy">copy</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.g" href="#pyvol.spheres.Spheres.g">g</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.identify_nonextraneous" href="#pyvol.spheres.Spheres.identify_nonextraneous">identify_nonextraneous</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.nearest" href="#pyvol.spheres.Spheres.nearest">nearest</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.nearest_coord_to_external" href="#pyvol.spheres.Spheres.nearest_coord_to_external">nearest_coord_to_external</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.r" href="#pyvol.spheres.Spheres.r">r</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.remove_duplicates" href="#pyvol.spheres.Spheres.remove_duplicates">remove_duplicates</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.remove_groups" href="#pyvol.spheres.Spheres.remove_groups">remove_groups</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.remove_ungrouped" href="#pyvol.spheres.Spheres.remove_ungrouped">remove_ungrouped</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.write" href="#pyvol.spheres.Spheres.write">write</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.xyz" href="#pyvol.spheres.Spheres.xyz">xyz</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.xyzr" href="#pyvol.spheres.Spheres.xyzr">xyzr</a></code></li>
<li><code><a title="pyvol.spheres.Spheres.xyzrg" href="#pyvol.spheres.Spheres.xyzrg">xyzrg</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>