<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>pyvol.cluster API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyvol.cluster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .spheres import Spheres
import logging
import numpy as np
import scipy

logger = logging.getLogger(__name__)

def cluster_within_r(spheres, radius, allow_new=True):
    &#34;&#34;&#34; Cluster spheres with the same radius using DBSCAN, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      radius (float): radius at which clustering is to occur
      allow_new (bool): permit new clusters? (Default value = True)

    &#34;&#34;&#34;
    from sklearn.cluster import DBSCAN

    r_indices = np.where(spheres.r == radius)[0]
    selected = spheres.xyzrg[r_indices, :]

    ungrouped_indices = np.where(selected[:, 4] == 0)[0]

    if ungrouped_indices.shape[0] &gt; 0:
        ungrouped_data = selected[ungrouped_indices]
        db = DBSCAN(eps=radius, min_samples=1).fit(ungrouped_data[:, 0:3])

        if allow_new:
            starting_index = np.amax(selected[:, 4]) + 1
            np.put(spheres.g, r_indices[ungrouped_indices], db.labels_ + starting_index)
        else:
            starting_index = np.amin(selected[:, 4]) - 1
            np.put(spheres.g, r_indices[ungrouped_indices], -1 * db.labels_ + starting_index)


def cluster_between_r(spheres, ref_radius, target_radius):
    &#34;&#34;&#34; Cluster spheres from a target radius to a reference radius, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      ref_radius (float): radius from which cluster identities will be drawn
      target_radius (float): radius to which cluster identities will be propagated

    &#34;&#34;&#34;
    ref_data = spheres.xyzrg[spheres.r == ref_radius]
    r_indices = np.where(spheres.r == target_radius)[0]
    target_data = spheres.xyzrg[r_indices]

    if (ref_data.shape[0] &gt; 0) and (target_data.shape[0] &gt; 0):

        kdtree = scipy.spatial.cKDTree(ref_data[:, 0:3])
        dist, indices = kdtree.query(target_data[:, 0:3], distance_upper_bound=ref_radius, n_jobs=-1)

        target_indices = indices &lt; ref_data.shape[0]
        ref_indices = indices[target_indices]

        np.put(spheres.g, r_indices[target_indices], ref_data[ref_indices, 4])


def cluster_improperly_grouped(spheres, radius, min_cluster_size=1, max_clusters=None):
    &#34;&#34;&#34; Reassigns improperly clustered spheres to &#39;proper&#39; clusters, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      radius (float): radius at which closest groups are identified
      min_cluster_size (int): minimum number of spheres in a &#39;proper&#39; cluster (Default value = 1)
      max_clusters (int): maximum number of &#39;proper&#39; clusters (Default value = None)

    &#34;&#34;&#34;
    min_group = np.amin(spheres.g)
    group_list = np.flip(np.arange(min_group, 0), axis=0)
    reassign_groups_to_closest(spheres, group_list, radius)

    spheres.remove_ungrouped()

    group_counts = np.bincount(spheres.g.astype(int))
    small_groups = np.where(group_counts &lt; min_cluster_size)[0]
    if len(small_groups) &gt; 1:
        # always includes the 0 group
        reassign_groups_to_closest(spheres, small_groups[1:], radius)
    disconnected_small_groups = np.where(group_counts &lt; min_cluster_size)[0]
    if len(disconnected_small_groups) &gt; 1:
        spheres.remove_groups(disconnected_small_groups)

    group_counts = np.bincount(spheres.g.astype(int))
    num_groups = np.count_nonzero(group_counts)

    if max_clusters is not None:
        if num_groups &gt; max_clusters:
            reassign_groups_to_closest(spheres, np.where(group_counts &gt; 0)[0], radius, iterations=(num_groups - max_clusters))
    logger.debug(&#34;Improperly grouped spheres re-clustered yielding {0} groups&#34;.format(num_groups))


def extract_groups(spheres, surf_radius=None, prefix=None):
    &#34;&#34;&#34; Extracts spheres belonging to each cluster from the complete input set and optionally calculates bounded surfaces

    Args:
      spheres (Spheres): complete set of input spheres
      surf_radius: radius used to calculate bounding spheres for individual groups (Default value = None)
      prefix: prefix to identify new surfaces (Default value = None)

    Returns:
      group_list ([Spheres]): a list of Spheres objects each corresponding to a different cluster

    &#34;&#34;&#34;
    groups = np.unique(spheres.g)

    group_list = []
    for group in groups:
        group_spheres = Spheres(xyzrg = spheres.xyzrg[spheres.g == group].copy())
        group_list.append(group_spheres)

    logger.debug(&#34;Extracting {0} groups from {1}&#34;.format(len(group_list), spheres.name))

    if surf_radius is not None:
        exterior_list = [group_spheres.calculate_surface(probe_radius=surf_radius)[0] for group_spheres in group_list]
        reindices = np.flip(np.argsort([s.mesh.volume for s in exterior_list]), 0)

        new_group_list = []
        new_ext_list = []
        for index in reindices:
            g_s = group_list[index]
            e_s = exterior_list[index]

            g_s.g = index
            e_s.g = index
            g_s.mesh = e_s.mesh.copy()

            if prefix is not None:
                g_s.name = &#34;{0}_p0_sp{1}&#34;.format(prefix, index)
            new_group_list.append(g_s)
            new_ext_list.append(e_s)

        return new_group_list
    else:
        return group_list


def hierarchically_cluster_spheres(spheres, ordered_radii, min_new_radius=None, min_cluster_size=10, max_clusters=None):
    &#34;&#34;&#34; Cluster spheres by grouping spheres at large radius and propagating those assignments down to smaller radii

    Args:
      spheres (Spheres): complete set of input spheres
      ordered_radii ([float]): list of radii ordered from largest to smallest
      min_new_radius (float): smallest spheres to keep (Default value = None)
      min_cluster_size (int): minimum number of spheres in a cluster (Default value = 10)
      max_clusters (int): maximum number of clusters (Default value = None)

    &#34;&#34;&#34;
    if min_new_radius is None:
        min_new_radius = np.amin(ordered_radii)

    for index, radius in enumerate(ordered_radii):
        initial_grouped = spheres.xyzrg[spheres.g != 0].shape[0]
        if index &gt; 0:
            cluster_between_r(spheres, ref_radius=ordered_radii[index - 1], target_radius=ordered_radii[index])

        cluster_within_r(spheres, radius, allow_new=(radius &gt;= min_new_radius))
    logger.debug(&#34;Finished naive sphere clustering for spheres in {0}&#34;.format(spheres.name))

    cluster_improperly_grouped(spheres, radius=ordered_radii[-1], min_cluster_size=min_cluster_size, max_clusters=max_clusters)
    logger.debug(&#34;Hierarchically clustered all spheres in {0}&#34;.format(spheres.name))


def identify_closest_grouped(spheres, group, radius):
    &#34;&#34;&#34; Identifies the closest &#39;properly&#39; grouped cluster to a specified group

    Args:
      spheres (Spheres): complete set of input spheres
      group (float): group for which to identify the closest clusters
      radius (float): radius at which to perform the search

    Returns:
      group (float): passthrough of input group
      closest (float): id of the closest cluster
      magnitude (int): number of pairwise closest connections between the queried group and the closest identified cluster
    &#34;&#34;&#34;
    target_indices = np.where((spheres.r == radius) &amp; (spheres.g == group))[0]
    grouped_indices = np.where((spheres.r == radius) &amp; (spheres.g &gt; 0) &amp; (spheres.g != group))[0]

    target_data = spheres.xyzrg[target_indices]
    grouped_data = spheres.xyzrg[grouped_indices]

    if (target_data.shape[0] &gt; 0) and (grouped_data.shape[0] &gt; 0):
        kdtree = scipy.spatial.cKDTree(grouped_data[:, 0:3])
        dist, indices = kdtree.query(target_data[:, 0:3], distance_upper_bound=1.41 * radius, n_jobs=-1)
        # 1.41 factor allows the two spheres to intersect at pi/4 from the closest point

        t_indices = indices &lt; grouped_data.shape[0]
        group_indices = indices[t_indices]
        if len(group_indices) &gt; 0:
            counts = np.bincount(grouped_data[group_indices,4].astype(int))
            closest = np.argmax(counts)
            magnitude = counts[closest]
            return [group, closest, magnitude]
        else:
            return [None, None, 0]
    else:
        return [None, None, 0]


def merge_sphere_list(s_list, r=None, g=None):
    &#34;&#34;&#34;

    Args:
      s_list ([Spheres]): list of input spheres
      r (float): radius value to assign to output Spheres (Default value = None)
      g (float): group value to assign to output Spheres (Default value = None)

    Returns:
      merged_spheres (Spheres): a single Spheres object containing the merged input lists
    &#34;&#34;&#34;
    selected_data_list = []

    for i, s in enumerate(s_list):
        if s is None:
            continue
        selected_data = s.xyzrg

        if r is not None:
            selected_data = selected_data[selected_data[:, 3] == r]
        if g is not None:
            selected_data = selected_data[selected_data[:, 4] == g]

        if selected_data.shape[0] &gt; 0:
            selected_data_list.append(selected_data)

    if len(selected_data_list) &gt; 0:
        return Spheres(xyzrg=np.vstack(selected_data_list))
    else:
        return None


def reassign_group(spheres, source_group, target_group):
    &#34;&#34;&#34; Reassign a group in place

    Args:
      spheres (Spheres): complete set of input spheres
      source_group (float): group to change
      target_group (float): new group id

    &#34;&#34;&#34;
    source_indices = np.where(spheres.g == source_group)

    np.put(spheres.g, source_indices, target_group)


def reassign_groups_to_closest(spheres, group_list, radius, iterations=None, preserve_largest=False):
    &#34;&#34;&#34; Reassign a group to the closest group as identified by maximum linkage; operates in place

    Args:
      spheres (Spheres): complete set of input spheres
      group_list ([float]): list of group ids which are to be iteratively reassigned
      radius (float): radius at which searches are to take place
      iterations (int): number of times to attempt to reassign groups (Default value = None)
      preserve_largest: keep the group id of the group with more members? (Default value = False)

    &#34;&#34;&#34;
    if iterations is None:
        iterations = len(group_list)

    for i in range(iterations):
        linkages = []
        for group in group_list:
            linkages.append(identify_closest_grouped(spheres, group, radius))

        nonzero_linkages = [link for link in linkages if link[2] &gt; 0]
        if len(nonzero_linkages) &gt; 0:
            best_link = sorted(nonzero_linkages, key=lambda x: x[2])[-1]
            if preserve_largest:
                group_sizes = np.bincount(spheres.g.astype(int))
                if group_sizes[best_link[0]] &gt; group_sizes[best_link[1]]:
                    best_link = [best_link[1], best_link[0]]

            reassign_group(spheres, best_link[0], best_link[1])
        else:
            break


def remove_interior(spheres):
    &#34;&#34;&#34; Remove all spheres which are completely enclosed in larger spheres; operates in place

    Args:
      spheres (Spheres): complete set of input spheres

    &#34;&#34;&#34;
    min_rad = np.amin(spheres.r)
    max_rad = np.amax(spheres.r)

    point_tree = scipy.spatial.cKDTree(spheres.xyz)
    neighbors = point_tree.query_ball_tree(point_tree, r=(max_rad - min_rad))

    interior_indices = []
    for point_index, nlist in enumerate(neighbors):
        if point_index in interior_indices:
            continue

        if len(nlist) &lt;= 1:
            continue

        inclusion = spheres.r[point_index] - spheres.r[nlist].reshape(-1, 1) - scipy.spatial.distance.cdist(spheres.xyz[nlist], spheres.xyz[point_index].reshape(1, -1))
        included_indices = np.where(inclusion &gt; 0)[0]
        if len(included_indices) &gt; 0:
            interior_indices.extend(list(np.array(nlist)[included_indices]))

    interior_indices = np.unique(interior_indices).astype(int)
    spheres.xyzrg = np.delete(spheres.xyzrg, interior_indices, axis=0)


def remove_overlap(spheres, radii=None, spacing=0.1, iterations=20, tolerance=0.02):
    &#34;&#34;&#34; Remove overlap between groups; operates in place

    Args:
      spheres (Spheres): complete set of input spheres
      radii ([float]): radii at which to perform searches for overlap (Default value = None)
      spacing (float): binning radius (Default value = 0.1)
      iterations (int): number of times to attempt overlap removal (Default value = 20)
      tolerance (float): overlap tolerance (Default value = 0.02)

    &#34;&#34;&#34;
    from sklearn.preprocessing import normalize

    groups = np.unique(spheres.g)[:-1]

    if radii is None:
        radii = [np.amax(spheres.r)]
        spacing = radii[0]

    for radius in radii:
        for group in groups:
            group_indices = np.where((spheres.g == group) &amp; (spheres.r &gt; (radius - spacing)) &amp; (spheres.r &lt;= radius))[0]
            other_indices = np.where((spheres.g != group) &amp; (spheres.r &gt; (radius - spacing)) &amp; (spheres.r &lt;= radius))[0]


            if len(group_indices) == 0 or len(other_indices) == 0:
                continue

            group_data = spheres.xyzrg[group_indices]
            other_data = spheres.xyzrg[other_indices]

            other_tree = scipy.spatial.cKDTree(other_data[:, 0:3])
            group_tree = scipy.spatial.cKDTree(group_data[:, 0:3])

            neighbors = group_tree.query_ball_tree(other_tree, r=2 * radius)

            altered_group_indices = []
            altered_other_indices = []

            for iteration in range(iterations):
                overlaps = np.zeros(len(neighbors))
                overlap_indices = -1 * np.ones(len(neighbors))

                for group_index, nlist in enumerate(neighbors):
                    if len(nlist) == 0:
                        continue
                    overlap = other_data[nlist, 3].reshape(-1, 1) + group_data[group_index, 3] - scipy.spatial.distance.cdist(other_data[nlist, 0:3], group_data[group_index, 0:3].reshape(1, -1))
                    most_overlapping_index = np.argmax(overlap)
                    if overlap[most_overlapping_index] &gt; 0:
                        overlaps[group_index] = overlap[most_overlapping_index]
                        overlap_indices[group_index] = nlist[most_overlapping_index]

                overlapped_group_indices = np.where(overlaps &gt; tolerance)[0]
                if len(overlapped_group_indices) == 0:
                    break

                overlaps = overlaps[overlapped_group_indices]
                overlap_indices = overlap_indices[overlapped_group_indices].astype(int)

                reorder = np.argsort(overlaps)[::-1]
                overlaps = overlaps[reorder]
                overlap_indices = overlap_indices[reorder]
                overlapped_group_indices = overlapped_group_indices[reorder]

                foo, closest_indices = np.unique(overlap_indices, return_index=True)
                overlaps = overlaps[closest_indices]
                overlap_indices = overlap_indices[closest_indices]
                overlapped_group_indices = overlapped_group_indices[closest_indices]

                overlap_adjustment = 0.25 * overlaps
                vector = overlap_adjustment[:, np.newaxis] * normalize(group_data[overlapped_group_indices, 0:3] - other_data[overlap_indices, 0:3])

                group_data[overlapped_group_indices, 0:3] = group_data[overlapped_group_indices, 0:3] + vector
                group_data[overlapped_group_indices, 3] = group_data[overlapped_group_indices, 3] - overlap_adjustment

                other_data[overlap_indices, 0:3] = other_data[overlap_indices, 0:3] - vector
                other_data[overlap_indices, 3] = other_data[overlap_indices, 3] - overlap_adjustment

                altered_group_indices.extend(list(overlapped_group_indices))
                altered_other_indices.extend(list(overlap_indices))

            altered_group_indices = np.unique(altered_group_indices).astype(int)
            altered_other_indices = np.unique(altered_other_indices).astype(int)

            spheres.xyzrg[group_indices[altered_group_indices]] = group_data[altered_group_indices]
            spheres.xyzrg[other_indices[altered_other_indices]] = other_data[altered_other_indices]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyvol.cluster.cluster_between_r"><code class="name flex">
<span>def <span class="ident">cluster_between_r</span></span>(<span>spheres, ref_radius, target_radius)</span>
</code></dt>
<dd>
<section class="desc"><p>Cluster spheres from a target radius to a reference radius, modifying input data in situ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>ref_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius from which cluster identities will be drawn</dd>
<dt><strong><code>target_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius to which cluster identities will be propagated</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_between_r(spheres, ref_radius, target_radius):
    &#34;&#34;&#34; Cluster spheres from a target radius to a reference radius, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      ref_radius (float): radius from which cluster identities will be drawn
      target_radius (float): radius to which cluster identities will be propagated

    &#34;&#34;&#34;
    ref_data = spheres.xyzrg[spheres.r == ref_radius]
    r_indices = np.where(spheres.r == target_radius)[0]
    target_data = spheres.xyzrg[r_indices]

    if (ref_data.shape[0] &gt; 0) and (target_data.shape[0] &gt; 0):

        kdtree = scipy.spatial.cKDTree(ref_data[:, 0:3])
        dist, indices = kdtree.query(target_data[:, 0:3], distance_upper_bound=ref_radius, n_jobs=-1)

        target_indices = indices &lt; ref_data.shape[0]
        ref_indices = indices[target_indices]

        np.put(spheres.g, r_indices[target_indices], ref_data[ref_indices, 4])</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.cluster_improperly_grouped"><code class="name flex">
<span>def <span class="ident">cluster_improperly_grouped</span></span>(<span>spheres, radius, min_cluster_size=1, max_clusters=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Reassigns improperly clustered spheres to 'proper' clusters, modifying input data in situ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius at which closest groups are identified</dd>
<dt><strong><code>min_cluster_size</code></strong> :&ensp;<code>int</code></dt>
<dd>minimum number of spheres in a 'proper' cluster (Default value = 1)</dd>
<dt><strong><code>max_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum number of 'proper' clusters (Default value = None)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_improperly_grouped(spheres, radius, min_cluster_size=1, max_clusters=None):
    &#34;&#34;&#34; Reassigns improperly clustered spheres to &#39;proper&#39; clusters, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      radius (float): radius at which closest groups are identified
      min_cluster_size (int): minimum number of spheres in a &#39;proper&#39; cluster (Default value = 1)
      max_clusters (int): maximum number of &#39;proper&#39; clusters (Default value = None)

    &#34;&#34;&#34;
    min_group = np.amin(spheres.g)
    group_list = np.flip(np.arange(min_group, 0), axis=0)
    reassign_groups_to_closest(spheres, group_list, radius)

    spheres.remove_ungrouped()

    group_counts = np.bincount(spheres.g.astype(int))
    small_groups = np.where(group_counts &lt; min_cluster_size)[0]
    if len(small_groups) &gt; 1:
        # always includes the 0 group
        reassign_groups_to_closest(spheres, small_groups[1:], radius)
    disconnected_small_groups = np.where(group_counts &lt; min_cluster_size)[0]
    if len(disconnected_small_groups) &gt; 1:
        spheres.remove_groups(disconnected_small_groups)

    group_counts = np.bincount(spheres.g.astype(int))
    num_groups = np.count_nonzero(group_counts)

    if max_clusters is not None:
        if num_groups &gt; max_clusters:
            reassign_groups_to_closest(spheres, np.where(group_counts &gt; 0)[0], radius, iterations=(num_groups - max_clusters))
    logger.debug(&#34;Improperly grouped spheres re-clustered yielding {0} groups&#34;.format(num_groups))</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.cluster_within_r"><code class="name flex">
<span>def <span class="ident">cluster_within_r</span></span>(<span>spheres, radius, allow_new=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Cluster spheres with the same radius using DBSCAN, modifying input data in situ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius at which clustering is to occur</dd>
<dt><strong><code>allow_new</code></strong> :&ensp;<code>bool</code></dt>
<dd>permit new clusters? (Default value = True)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cluster_within_r(spheres, radius, allow_new=True):
    &#34;&#34;&#34; Cluster spheres with the same radius using DBSCAN, modifying input data in situ

    Args:
      spheres (Spheres): complete set of input spheres
      radius (float): radius at which clustering is to occur
      allow_new (bool): permit new clusters? (Default value = True)

    &#34;&#34;&#34;
    from sklearn.cluster import DBSCAN

    r_indices = np.where(spheres.r == radius)[0]
    selected = spheres.xyzrg[r_indices, :]

    ungrouped_indices = np.where(selected[:, 4] == 0)[0]

    if ungrouped_indices.shape[0] &gt; 0:
        ungrouped_data = selected[ungrouped_indices]
        db = DBSCAN(eps=radius, min_samples=1).fit(ungrouped_data[:, 0:3])

        if allow_new:
            starting_index = np.amax(selected[:, 4]) + 1
            np.put(spheres.g, r_indices[ungrouped_indices], db.labels_ + starting_index)
        else:
            starting_index = np.amin(selected[:, 4]) - 1
            np.put(spheres.g, r_indices[ungrouped_indices], -1 * db.labels_ + starting_index)</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.extract_groups"><code class="name flex">
<span>def <span class="ident">extract_groups</span></span>(<span>spheres, surf_radius=None, prefix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Extracts spheres belonging to each cluster from the complete input set and optionally calculates bounded surfaces</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>surf_radius</code></strong></dt>
<dd>radius used to calculate bounding spheres for individual groups (Default value = None)</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>prefix to identify new surfaces (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>group_list</code></strong> :&ensp;[<code>Spheres</code>]</dt>
<dd>a list of Spheres objects each corresponding to a different cluster</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_groups(spheres, surf_radius=None, prefix=None):
    &#34;&#34;&#34; Extracts spheres belonging to each cluster from the complete input set and optionally calculates bounded surfaces

    Args:
      spheres (Spheres): complete set of input spheres
      surf_radius: radius used to calculate bounding spheres for individual groups (Default value = None)
      prefix: prefix to identify new surfaces (Default value = None)

    Returns:
      group_list ([Spheres]): a list of Spheres objects each corresponding to a different cluster

    &#34;&#34;&#34;
    groups = np.unique(spheres.g)

    group_list = []
    for group in groups:
        group_spheres = Spheres(xyzrg = spheres.xyzrg[spheres.g == group].copy())
        group_list.append(group_spheres)

    logger.debug(&#34;Extracting {0} groups from {1}&#34;.format(len(group_list), spheres.name))

    if surf_radius is not None:
        exterior_list = [group_spheres.calculate_surface(probe_radius=surf_radius)[0] for group_spheres in group_list]
        reindices = np.flip(np.argsort([s.mesh.volume for s in exterior_list]), 0)

        new_group_list = []
        new_ext_list = []
        for index in reindices:
            g_s = group_list[index]
            e_s = exterior_list[index]

            g_s.g = index
            e_s.g = index
            g_s.mesh = e_s.mesh.copy()

            if prefix is not None:
                g_s.name = &#34;{0}_p0_sp{1}&#34;.format(prefix, index)
            new_group_list.append(g_s)
            new_ext_list.append(e_s)

        return new_group_list
    else:
        return group_list</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.hierarchically_cluster_spheres"><code class="name flex">
<span>def <span class="ident">hierarchically_cluster_spheres</span></span>(<span>spheres, ordered_radii, min_new_radius=None, min_cluster_size=10, max_clusters=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Cluster spheres by grouping spheres at large radius and propagating those assignments down to smaller radii</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>ordered_radii</code></strong> :&ensp;[<code>float</code>]</dt>
<dd>list of radii ordered from largest to smallest</dd>
<dt><strong><code>min_new_radius</code></strong> :&ensp;<code>float</code></dt>
<dd>smallest spheres to keep (Default value = None)</dd>
<dt><strong><code>min_cluster_size</code></strong> :&ensp;<code>int</code></dt>
<dd>minimum number of spheres in a cluster (Default value = 10)</dd>
<dt><strong><code>max_clusters</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum number of clusters (Default value = None)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hierarchically_cluster_spheres(spheres, ordered_radii, min_new_radius=None, min_cluster_size=10, max_clusters=None):
    &#34;&#34;&#34; Cluster spheres by grouping spheres at large radius and propagating those assignments down to smaller radii

    Args:
      spheres (Spheres): complete set of input spheres
      ordered_radii ([float]): list of radii ordered from largest to smallest
      min_new_radius (float): smallest spheres to keep (Default value = None)
      min_cluster_size (int): minimum number of spheres in a cluster (Default value = 10)
      max_clusters (int): maximum number of clusters (Default value = None)

    &#34;&#34;&#34;
    if min_new_radius is None:
        min_new_radius = np.amin(ordered_radii)

    for index, radius in enumerate(ordered_radii):
        initial_grouped = spheres.xyzrg[spheres.g != 0].shape[0]
        if index &gt; 0:
            cluster_between_r(spheres, ref_radius=ordered_radii[index - 1], target_radius=ordered_radii[index])

        cluster_within_r(spheres, radius, allow_new=(radius &gt;= min_new_radius))
    logger.debug(&#34;Finished naive sphere clustering for spheres in {0}&#34;.format(spheres.name))

    cluster_improperly_grouped(spheres, radius=ordered_radii[-1], min_cluster_size=min_cluster_size, max_clusters=max_clusters)
    logger.debug(&#34;Hierarchically clustered all spheres in {0}&#34;.format(spheres.name))</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.identify_closest_grouped"><code class="name flex">
<span>def <span class="ident">identify_closest_grouped</span></span>(<span>spheres, group, radius)</span>
</code></dt>
<dd>
<section class="desc"><p>Identifies the closest 'properly' grouped cluster to a specified group</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>float</code></dt>
<dd>group for which to identify the closest clusters</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius at which to perform the search</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>float</code></dt>
<dd>passthrough of input group</dd>
<dt><strong><code>closest</code></strong> :&ensp;<code>float</code></dt>
<dd>id of the closest cluster</dd>
<dt><strong><code>magnitude</code></strong> :&ensp;<code>int</code></dt>
<dd>number of pairwise closest connections between the queried group and the closest identified cluster</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_closest_grouped(spheres, group, radius):
    &#34;&#34;&#34; Identifies the closest &#39;properly&#39; grouped cluster to a specified group

    Args:
      spheres (Spheres): complete set of input spheres
      group (float): group for which to identify the closest clusters
      radius (float): radius at which to perform the search

    Returns:
      group (float): passthrough of input group
      closest (float): id of the closest cluster
      magnitude (int): number of pairwise closest connections between the queried group and the closest identified cluster
    &#34;&#34;&#34;
    target_indices = np.where((spheres.r == radius) &amp; (spheres.g == group))[0]
    grouped_indices = np.where((spheres.r == radius) &amp; (spheres.g &gt; 0) &amp; (spheres.g != group))[0]

    target_data = spheres.xyzrg[target_indices]
    grouped_data = spheres.xyzrg[grouped_indices]

    if (target_data.shape[0] &gt; 0) and (grouped_data.shape[0] &gt; 0):
        kdtree = scipy.spatial.cKDTree(grouped_data[:, 0:3])
        dist, indices = kdtree.query(target_data[:, 0:3], distance_upper_bound=1.41 * radius, n_jobs=-1)
        # 1.41 factor allows the two spheres to intersect at pi/4 from the closest point

        t_indices = indices &lt; grouped_data.shape[0]
        group_indices = indices[t_indices]
        if len(group_indices) &gt; 0:
            counts = np.bincount(grouped_data[group_indices,4].astype(int))
            closest = np.argmax(counts)
            magnitude = counts[closest]
            return [group, closest, magnitude]
        else:
            return [None, None, 0]
    else:
        return [None, None, 0]</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.merge_sphere_list"><code class="name flex">
<span>def <span class="ident">merge_sphere_list</span></span>(<span>s_list, r=None, g=None)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>s_list</code></strong> :&ensp;[<code>Spheres</code>]</dt>
<dd>list of input spheres</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>radius value to assign to output Spheres (Default value = None)</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>float</code></dt>
<dd>group value to assign to output Spheres (Default value = None)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>merged_spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>a single Spheres object containing the merged input lists</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_sphere_list(s_list, r=None, g=None):
    &#34;&#34;&#34;

    Args:
      s_list ([Spheres]): list of input spheres
      r (float): radius value to assign to output Spheres (Default value = None)
      g (float): group value to assign to output Spheres (Default value = None)

    Returns:
      merged_spheres (Spheres): a single Spheres object containing the merged input lists
    &#34;&#34;&#34;
    selected_data_list = []

    for i, s in enumerate(s_list):
        if s is None:
            continue
        selected_data = s.xyzrg

        if r is not None:
            selected_data = selected_data[selected_data[:, 3] == r]
        if g is not None:
            selected_data = selected_data[selected_data[:, 4] == g]

        if selected_data.shape[0] &gt; 0:
            selected_data_list.append(selected_data)

    if len(selected_data_list) &gt; 0:
        return Spheres(xyzrg=np.vstack(selected_data_list))
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.reassign_group"><code class="name flex">
<span>def <span class="ident">reassign_group</span></span>(<span>spheres, source_group, target_group)</span>
</code></dt>
<dd>
<section class="desc"><p>Reassign a group in place</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>source_group</code></strong> :&ensp;<code>float</code></dt>
<dd>group to change</dd>
<dt><strong><code>target_group</code></strong> :&ensp;<code>float</code></dt>
<dd>new group id</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reassign_group(spheres, source_group, target_group):
    &#34;&#34;&#34; Reassign a group in place

    Args:
      spheres (Spheres): complete set of input spheres
      source_group (float): group to change
      target_group (float): new group id

    &#34;&#34;&#34;
    source_indices = np.where(spheres.g == source_group)

    np.put(spheres.g, source_indices, target_group)</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.reassign_groups_to_closest"><code class="name flex">
<span>def <span class="ident">reassign_groups_to_closest</span></span>(<span>spheres, group_list, radius, iterations=None, preserve_largest=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Reassign a group to the closest group as identified by maximum linkage; operates in place</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>group_list</code></strong> :&ensp;[<code>float</code>]</dt>
<dd>list of group ids which are to be iteratively reassigned</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>radius at which searches are to take place</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>number of times to attempt to reassign groups (Default value = None)</dd>
<dt><strong><code>preserve_largest</code></strong></dt>
<dd>keep the group id of the group with more members? (Default value = False)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reassign_groups_to_closest(spheres, group_list, radius, iterations=None, preserve_largest=False):
    &#34;&#34;&#34; Reassign a group to the closest group as identified by maximum linkage; operates in place

    Args:
      spheres (Spheres): complete set of input spheres
      group_list ([float]): list of group ids which are to be iteratively reassigned
      radius (float): radius at which searches are to take place
      iterations (int): number of times to attempt to reassign groups (Default value = None)
      preserve_largest: keep the group id of the group with more members? (Default value = False)

    &#34;&#34;&#34;
    if iterations is None:
        iterations = len(group_list)

    for i in range(iterations):
        linkages = []
        for group in group_list:
            linkages.append(identify_closest_grouped(spheres, group, radius))

        nonzero_linkages = [link for link in linkages if link[2] &gt; 0]
        if len(nonzero_linkages) &gt; 0:
            best_link = sorted(nonzero_linkages, key=lambda x: x[2])[-1]
            if preserve_largest:
                group_sizes = np.bincount(spheres.g.astype(int))
                if group_sizes[best_link[0]] &gt; group_sizes[best_link[1]]:
                    best_link = [best_link[1], best_link[0]]

            reassign_group(spheres, best_link[0], best_link[1])
        else:
            break</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.remove_interior"><code class="name flex">
<span>def <span class="ident">remove_interior</span></span>(<span>spheres)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all spheres which are completely enclosed in larger spheres; operates in place</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_interior(spheres):
    &#34;&#34;&#34; Remove all spheres which are completely enclosed in larger spheres; operates in place

    Args:
      spheres (Spheres): complete set of input spheres

    &#34;&#34;&#34;
    min_rad = np.amin(spheres.r)
    max_rad = np.amax(spheres.r)

    point_tree = scipy.spatial.cKDTree(spheres.xyz)
    neighbors = point_tree.query_ball_tree(point_tree, r=(max_rad - min_rad))

    interior_indices = []
    for point_index, nlist in enumerate(neighbors):
        if point_index in interior_indices:
            continue

        if len(nlist) &lt;= 1:
            continue

        inclusion = spheres.r[point_index] - spheres.r[nlist].reshape(-1, 1) - scipy.spatial.distance.cdist(spheres.xyz[nlist], spheres.xyz[point_index].reshape(1, -1))
        included_indices = np.where(inclusion &gt; 0)[0]
        if len(included_indices) &gt; 0:
            interior_indices.extend(list(np.array(nlist)[included_indices]))

    interior_indices = np.unique(interior_indices).astype(int)
    spheres.xyzrg = np.delete(spheres.xyzrg, interior_indices, axis=0)</code></pre>
</details>
</dd>
<dt id="pyvol.cluster.remove_overlap"><code class="name flex">
<span>def <span class="ident">remove_overlap</span></span>(<span>spheres, radii=None, spacing=0.1, iterations=20, tolerance=0.02)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove overlap between groups; operates in place</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spheres</code></strong> :&ensp;<code>Spheres</code></dt>
<dd>complete set of input spheres</dd>
<dt><strong><code>radii</code></strong> :&ensp;[<code>float</code>]</dt>
<dd>radii at which to perform searches for overlap (Default value = None)</dd>
<dt><strong><code>spacing</code></strong> :&ensp;<code>float</code></dt>
<dd>binning radius (Default value = 0.1)</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code></dt>
<dd>number of times to attempt overlap removal (Default value = 20)</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>overlap tolerance (Default value = 0.02)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_overlap(spheres, radii=None, spacing=0.1, iterations=20, tolerance=0.02):
    &#34;&#34;&#34; Remove overlap between groups; operates in place

    Args:
      spheres (Spheres): complete set of input spheres
      radii ([float]): radii at which to perform searches for overlap (Default value = None)
      spacing (float): binning radius (Default value = 0.1)
      iterations (int): number of times to attempt overlap removal (Default value = 20)
      tolerance (float): overlap tolerance (Default value = 0.02)

    &#34;&#34;&#34;
    from sklearn.preprocessing import normalize

    groups = np.unique(spheres.g)[:-1]

    if radii is None:
        radii = [np.amax(spheres.r)]
        spacing = radii[0]

    for radius in radii:
        for group in groups:
            group_indices = np.where((spheres.g == group) &amp; (spheres.r &gt; (radius - spacing)) &amp; (spheres.r &lt;= radius))[0]
            other_indices = np.where((spheres.g != group) &amp; (spheres.r &gt; (radius - spacing)) &amp; (spheres.r &lt;= radius))[0]


            if len(group_indices) == 0 or len(other_indices) == 0:
                continue

            group_data = spheres.xyzrg[group_indices]
            other_data = spheres.xyzrg[other_indices]

            other_tree = scipy.spatial.cKDTree(other_data[:, 0:3])
            group_tree = scipy.spatial.cKDTree(group_data[:, 0:3])

            neighbors = group_tree.query_ball_tree(other_tree, r=2 * radius)

            altered_group_indices = []
            altered_other_indices = []

            for iteration in range(iterations):
                overlaps = np.zeros(len(neighbors))
                overlap_indices = -1 * np.ones(len(neighbors))

                for group_index, nlist in enumerate(neighbors):
                    if len(nlist) == 0:
                        continue
                    overlap = other_data[nlist, 3].reshape(-1, 1) + group_data[group_index, 3] - scipy.spatial.distance.cdist(other_data[nlist, 0:3], group_data[group_index, 0:3].reshape(1, -1))
                    most_overlapping_index = np.argmax(overlap)
                    if overlap[most_overlapping_index] &gt; 0:
                        overlaps[group_index] = overlap[most_overlapping_index]
                        overlap_indices[group_index] = nlist[most_overlapping_index]

                overlapped_group_indices = np.where(overlaps &gt; tolerance)[0]
                if len(overlapped_group_indices) == 0:
                    break

                overlaps = overlaps[overlapped_group_indices]
                overlap_indices = overlap_indices[overlapped_group_indices].astype(int)

                reorder = np.argsort(overlaps)[::-1]
                overlaps = overlaps[reorder]
                overlap_indices = overlap_indices[reorder]
                overlapped_group_indices = overlapped_group_indices[reorder]

                foo, closest_indices = np.unique(overlap_indices, return_index=True)
                overlaps = overlaps[closest_indices]
                overlap_indices = overlap_indices[closest_indices]
                overlapped_group_indices = overlapped_group_indices[closest_indices]

                overlap_adjustment = 0.25 * overlaps
                vector = overlap_adjustment[:, np.newaxis] * normalize(group_data[overlapped_group_indices, 0:3] - other_data[overlap_indices, 0:3])

                group_data[overlapped_group_indices, 0:3] = group_data[overlapped_group_indices, 0:3] + vector
                group_data[overlapped_group_indices, 3] = group_data[overlapped_group_indices, 3] - overlap_adjustment

                other_data[overlap_indices, 0:3] = other_data[overlap_indices, 0:3] - vector
                other_data[overlap_indices, 3] = other_data[overlap_indices, 3] - overlap_adjustment

                altered_group_indices.extend(list(overlapped_group_indices))
                altered_other_indices.extend(list(overlap_indices))

            altered_group_indices = np.unique(altered_group_indices).astype(int)
            altered_other_indices = np.unique(altered_other_indices).astype(int)

            spheres.xyzrg[group_indices[altered_group_indices]] = group_data[altered_group_indices]
            spheres.xyzrg[other_indices[altered_other_indices]] = other_data[altered_other_indices]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyvol" href="index.html">pyvol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyvol.cluster.cluster_between_r" href="#pyvol.cluster.cluster_between_r">cluster_between_r</a></code></li>
<li><code><a title="pyvol.cluster.cluster_improperly_grouped" href="#pyvol.cluster.cluster_improperly_grouped">cluster_improperly_grouped</a></code></li>
<li><code><a title="pyvol.cluster.cluster_within_r" href="#pyvol.cluster.cluster_within_r">cluster_within_r</a></code></li>
<li><code><a title="pyvol.cluster.extract_groups" href="#pyvol.cluster.extract_groups">extract_groups</a></code></li>
<li><code><a title="pyvol.cluster.hierarchically_cluster_spheres" href="#pyvol.cluster.hierarchically_cluster_spheres">hierarchically_cluster_spheres</a></code></li>
<li><code><a title="pyvol.cluster.identify_closest_grouped" href="#pyvol.cluster.identify_closest_grouped">identify_closest_grouped</a></code></li>
<li><code><a title="pyvol.cluster.merge_sphere_list" href="#pyvol.cluster.merge_sphere_list">merge_sphere_list</a></code></li>
<li><code><a title="pyvol.cluster.reassign_group" href="#pyvol.cluster.reassign_group">reassign_group</a></code></li>
<li><code><a title="pyvol.cluster.reassign_groups_to_closest" href="#pyvol.cluster.reassign_groups_to_closest">reassign_groups_to_closest</a></code></li>
<li><code><a title="pyvol.cluster.remove_interior" href="#pyvol.cluster.remove_interior">remove_interior</a></code></li>
<li><code><a title="pyvol.cluster.remove_overlap" href="#pyvol.cluster.remove_overlap">remove_overlap</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>